name: 'Perf: Audit'

on:
  pull_request:
    branches: [master]
  push:
    branches: [master]

env:
  PERF_AUDIT_REPO: misty-step/vox-perf-audit

jobs:
  pr:
    name: Perf Audit (PR Comment)
    if: github.event_name == 'pull_request'
    runs-on: macos-14
    timeout-minutes: 20
    concurrency:
      group: perf-audit-pr-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    permissions:
      contents: read
      pull-requests: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode_16.2.app/Contents/Developer

      - name: Perf Audit
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          ELEVENLABS_API_KEY: ${{ secrets.ELEVENLABS_API_KEY }}
          DEEPGRAM_API_KEY: ${{ secrets.DEEPGRAM_API_KEY }}
        run: |
          set -euo pipefail

          OUT_DIR="perf-out"
          mkdir -p "$OUT_DIR"

          PR_NUMBER="${{ github.event.pull_request.number }}"
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          PROVIDER_HEAD="$OUT_DIR/head-provider.json"
          CODEPATH_HEAD="$OUT_DIR/head-codepath.json"
          PRIMARY_HEAD="$OUT_DIR/head.json"

          SHORT_FIXTURE="$OUT_DIR/fixture-short.caf"
          MEDIUM_FIXTURE="$OUT_DIR/fixture-medium.caf"
          bash scripts/perf/make-fixture-audio.sh --variant short "$SHORT_FIXTURE"
          bash scripts/perf/make-fixture-audio.sh --variant medium "$MEDIUM_FIXTURE"

          # Deterministic lane always runs (no external API dependence).
          swift run VoxPerfAudit \
            --lane codepath \
            --audio "$SHORT_FIXTURE" \
            --audio "$MEDIUM_FIXTURE" \
            --output "$CODEPATH_HEAD" \
            --iterations 5 \
            --warmup 1 \
            --commit "${GITHUB_SHA}" \
            --pr "$PR_NUMBER" \
            --label "ci-codepath"

          if [ -z "${OPENROUTER_API_KEY:-}" ] || { [ -z "${ELEVENLABS_API_KEY:-}" ] && [ -z "${DEEPGRAM_API_KEY:-}" ]; }; then
            echo "Provider lane skipped: missing OPENROUTER_API_KEY and/or STT API key in CI."
          else
            swift run VoxPerfAudit \
              --lane provider \
              --audio "$SHORT_FIXTURE" \
              --audio "$MEDIUM_FIXTURE" \
              --output "$PROVIDER_HEAD" \
              --iterations 5 \
              --warmup 1 \
              --commit "${GITHUB_SHA}" \
              --pr "$PR_NUMBER" \
              --label "ci-provider"
          fi

          if [ -f "$PROVIDER_HEAD" ]; then
            cp "$PROVIDER_HEAD" "$PRIMARY_HEAD"
          else
            cp "$CODEPATH_HEAD" "$PRIMARY_HEAD"
          fi

          # Combined history dir: cross-PR runs + master baselines.
          # This is intentionally longitudinal so perf comments can show
          # trends over time (not just the current PR commit range).
          HISTORY_DIR="$OUT_DIR/history"
          mkdir -p "$HISTORY_DIR"
          BASE_JSON="$OUT_DIR/base.json"
          BASE_SHA_USED="$BASE_SHA"
          BASE_MODE="missing"
          CHANGED_FILES="$OUT_DIR/changed-files.txt"
          git diff --name-only "$BASE_SHA" "$GITHUB_SHA" > "$CHANGED_FILES" || true

          # Optional baseline: pulled from dedicated perf audit store (public, no token needed).
          AUDIT_REPO="${PERF_AUDIT_REPO}"

          fetch_raw_content() {
            local path="$1"
            local dest="$2"
            gh api \
              -H "Accept: application/vnd.github.raw" \
              "repos/${AUDIT_REPO}/contents/${path}" > "$dest" 2>/dev/null \
              || {
                rm -f "$dest"
                return 1
              }
          }

          # Pre-fetch baseline SHA listing once via Git Trees API.
          # Query the audit subtree directly to avoid huge root-tree payloads.
          _AUDIT_DEFAULT="$(gh api "repos/${AUDIT_REPO}" --jq '.default_branch' 2>/dev/null || echo 'main')"
          _AUDIT_TREE_SHA="$(gh api "repos/${AUDIT_REPO}/git/trees/${_AUDIT_DEFAULT}" \
            --jq '.tree[] | select(.path=="audit" and .type=="tree") | .sha' 2>/dev/null | head -n 1 || true)"
          if [ -n "$_AUDIT_TREE_SHA" ]; then
            AVAILABLE_SHAS="$(gh api "repos/${AUDIT_REPO}/git/trees/${_AUDIT_TREE_SHA}?recursive=1" \
              --jq '[.tree[] | select(.path | test("^[^/]+\\.json$")) | .path | rtrimstr(".json")] | join("\n")' 2>/dev/null || true)"
            PR_HISTORY_PATHS="$(gh api "repos/${AUDIT_REPO}/git/trees/${_AUDIT_TREE_SHA}?recursive=1" \
              --jq '[.tree[] | select(.path | test("^pr/[0-9]+/.+\\.json$")) | .path] | sort_by((capture("^pr/(?<pr>[0-9]+)/").pr | tonumber), .) | join("\n")' 2>/dev/null || true)"
          else
            AVAILABLE_SHAS="$(gh api "repos/${AUDIT_REPO}/git/trees/${_AUDIT_DEFAULT}?recursive=1" \
              --jq '[.tree[] | select(.path | test("^audit/[^/]+\\.json$")) | .path | ltrimstr("audit/") | rtrimstr(".json")] | join("\n")' 2>/dev/null || true)"
            PR_HISTORY_PATHS="$(gh api "repos/${AUDIT_REPO}/git/trees/${_AUDIT_DEFAULT}?recursive=1" \
              --jq '[.tree[] | select(.path | test("^audit/pr/[0-9]+/.+\\.json$")) | .path | ltrimstr("audit/")] | sort_by((capture("^pr/(?<pr>[0-9]+)/").pr | tonumber), .) | join("\n")' 2>/dev/null || true)"
          fi
          if [ -z "$AVAILABLE_SHAS" ]; then
            echo "No baseline index from ${AUDIT_REPO}; continuing without persisted history."
          fi

          # Cross-PR history: include historical PR runs (bounded) for trend context.
          PR_HISTORY_MAX=500
          PR_HISTORY_TOTAL="$(printf '%s\n' "$PR_HISTORY_PATHS" | sed '/^$/d' | wc -l | tr -d ' ')"
          if [ "${PR_HISTORY_TOTAL:-0}" -gt "$PR_HISTORY_MAX" ]; then
            echo "PR history has ${PR_HISTORY_TOTAL} files; truncating to ${PR_HISTORY_MAX}."
          fi
          while IFS= read -r path; do
            [ -n "$path" ] || continue
            fname="$(printf '%s' "$path" | tr '/' '_')"
            fetch_raw_content "audit/${path}" "$HISTORY_DIR/pr-${fname}" || true
          done < <(printf '%s\n' "$PR_HISTORY_PATHS" | sed '/^$/d' | tail -n "$PR_HISTORY_MAX")

          # Master baseline history: last 60 master commits with persisted baselines.
          # Provides cross-PR trend context so the chart isn't reset each PR.
          # Uses git log for correct chronological ordering (SHA sort ≠ time order).
          if [ -n "$AVAILABLE_SHAS" ]; then
            git fetch --no-tags origin master >/dev/null 2>&1 || true
            _MASTER_COUNT=0
            while IFS= read -r sha; do
              [ -n "$sha" ] || continue
              if printf '%s\n' "$AVAILABLE_SHAS" | grep -qxF "$sha"; then
                fetch_raw_content "audit/${sha}.json" "$HISTORY_DIR/master-${sha}.json" || true
                _MASTER_COUNT=$((_MASTER_COUNT + 1))
                [ "$_MASTER_COUNT" -ge 60 ] && break
              fi
            done < <(git log --first-parent origin/master --format="%H" 2>/dev/null | head -n 200 || true)
          fi

          if [ -f "$PROVIDER_HEAD" ]; then
            # Try exact base SHA first.
            if fetch_raw_content "audit/${BASE_SHA}.json" "$BASE_JSON" && [ -s "$BASE_JSON" ]; then
              BASE_SHA_USED="$BASE_SHA"
              BASE_MODE="exact"
            else
              # Walk ancestry for nearest persisted ancestor.
              # Uses pre-fetched AVAILABLE_SHAS; 0 extra API calls for the intersection.
              while IFS= read -r candidate; do
                [ -n "$candidate" ] || continue
                if printf '%s\n' "$AVAILABLE_SHAS" | grep -qxF "$candidate"; then
                  if fetch_raw_content "audit/${candidate}.json" "$BASE_JSON" && [ -s "$BASE_JSON" ]; then
                    BASE_SHA_USED="$candidate"
                    BASE_MODE="nearest_ancestor"
                    break
                  fi
                fi
              done < <(git rev-list --max-count=400 "$BASE_SHA" 2>/dev/null || true)
            fi
          fi

          FORMAT_ARGS=(
            --head "$PRIMARY_HEAD"
            --head-sha "$GITHUB_SHA"
            --history-dir "$HISTORY_DIR"
            --history-max 24
            --timeline-max 16
            --requested-base-sha "$BASE_SHA"
            --base-sha "$BASE_SHA_USED"
            --base-mode "$BASE_MODE"
            --changed-files "$CHANGED_FILES"
            --out "$OUT_DIR/report.md"
          )
          if [ -f "$CODEPATH_HEAD" ] && [ -f "$PROVIDER_HEAD" ]; then
            FORMAT_ARGS+=(--codepath-head "$CODEPATH_HEAD")
          fi
          if [ -s "$BASE_JSON" ]; then
            FORMAT_ARGS+=(--base "$BASE_JSON")
          fi
          if [ "${VOX_PERF_RENDER_MERMAID:-0}" = "1" ]; then
            FORMAT_ARGS+=(--render-mermaid-charts)
          fi

          python3 scripts/perf/format-perf-report.py "${FORMAT_ARGS[@]}"

          bash scripts/perf/post-pr-comment.sh "$PR_NUMBER" "$OUT_DIR/report.md"

      - name: Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: perf-audit-pr-${{ github.run_number }}
          path: perf-out/
          retention-days: 30

  master:
    name: Perf Audit (Persist Baseline)
    if: github.event_name == 'push'
    runs-on: macos-14
    timeout-minutes: 20
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode_16.2.app/Contents/Developer

      - name: Run Audit
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          ELEVENLABS_API_KEY: ${{ secrets.ELEVENLABS_API_KEY }}
          DEEPGRAM_API_KEY: ${{ secrets.DEEPGRAM_API_KEY }}
        run: |
          set -euo pipefail

          OUT_DIR="perf-out"
          mkdir -p "$OUT_DIR"

          if [ -z "${OPENROUTER_API_KEY:-}" ] || { [ -z "${ELEVENLABS_API_KEY:-}" ] && [ -z "${DEEPGRAM_API_KEY:-}" ]; }; then
            echo "Perf audit skipped: missing OPENROUTER_API_KEY and/or STT API key."
            exit 0
          fi

          SHORT_FIXTURE="$OUT_DIR/fixture-short.caf"
          MEDIUM_FIXTURE="$OUT_DIR/fixture-medium.caf"
          bash scripts/perf/make-fixture-audio.sh --variant short "$SHORT_FIXTURE"
          bash scripts/perf/make-fixture-audio.sh --variant medium "$MEDIUM_FIXTURE"

          swift run VoxPerfAudit \
            --lane provider \
            --audio "$SHORT_FIXTURE" \
            --audio "$MEDIUM_FIXTURE" \
            --output "$OUT_DIR/head.json" \
            --iterations 10 \
            --warmup 1 \
            --commit "${GITHUB_SHA}" \
            --label "ci-master-provider"

          swift run VoxPerfAudit \
            --lane codepath \
            --audio "$SHORT_FIXTURE" \
            --audio "$MEDIUM_FIXTURE" \
            --output "$OUT_DIR/head-codepath.json" \
            --iterations 10 \
            --warmup 1 \
            --commit "${GITHUB_SHA}" \
            --label "ci-master-codepath"

      - name: Persist To vox-perf-audit
        if: always() && hashFiles('perf-out/head.json') != ''
        env:
          GH_TOKEN: ${{ secrets.PERF_AUDIT_TOKEN }}
        run: |
          set -euo pipefail

          if [ -z "${GH_TOKEN:-}" ]; then
            echo "PERF_AUDIT_TOKEN not set; skipping persist to vox-perf-audit."
            exit 0
          fi

          SHA="${GITHUB_SHA}"
          AUDIT_REPO="${PERF_AUDIT_REPO}"
          DEST_PATH="audit/${SHA}.json"

          if gh api "repos/${AUDIT_REPO}/contents/${DEST_PATH}" >/dev/null 2>&1; then
            echo "Already exists: ${DEST_PATH} — skipping."
            exit 0
          fi

          # Base64 encode and upload via Contents API (create, idempotent on 422).
          PAYLOAD="$(mktemp "${RUNNER_TEMP:-/tmp}/vox-perf-upload.XXXXXX.json")"
          CONTENT="$(base64 < perf-out/head.json | tr -d '\n')"
          jq -n \
            --arg message "perf(audit): ${SHA}" \
            --arg content "$CONTENT" \
            '{
              message: $message,
              content: $content,
              committer: {
                name: "github-actions[bot]",
                email: "41898282+github-actions[bot]@users.noreply.github.com"
              }
            }' > "$PAYLOAD"

          if HTTP_OUT="$(gh api \
            --method PUT \
            "repos/${AUDIT_REPO}/contents/${DEST_PATH}" \
            --input "$PAYLOAD" \
            2>&1)"; then
            echo "Persisted ${DEST_PATH} to ${AUDIT_REPO}"
          elif echo "$HTTP_OUT" | grep -Eqi "already exists|HTTP/[0-9.]+ 422|sha wasn't supplied"; then
            echo "Already exists: ${DEST_PATH} — skipping."
          else
            echo "ERROR uploading ${DEST_PATH}: $HTTP_OUT" >&2
            rm -f "$PAYLOAD"
            exit 1
          fi
          rm -f "$PAYLOAD"

      - name: Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: perf-audit-master-${{ github.run_number }}
          path: perf-out/
          retention-days: 30
