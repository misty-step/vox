#!/usr/bin/env node

// Formats promptfoo JSON into a markdown report for manual polish review.
// Usage: node format-polish-report.js < output.json > report.md

const fs = require("fs");

const input = fs.readFileSync(process.stdin.fd, "utf-8");
const data = JSON.parse(input);

const resultsRoot = data.results || {};
const rows = resultsRoot.results || [];
const config = data.config || {};

const providersInOrder = (config.providers || [])
  .map((p) => p.id)
  .filter(Boolean);

const providerLabel = (providerId) => {
  if (!providerId) return "—";
  return providerId.replace(/^openrouter:/, "");
};

const groupedByTest = new Map();
for (const r of rows) {
  const idx = r.testIdx ?? r.testCase?.description ?? "unknown";
  const list = groupedByTest.get(idx) || [];
  list.push(r);
  groupedByTest.set(idx, list);
}

const testOrder = Array.from(groupedByTest.keys()).sort((a, b) => {
  // Prefer numeric testIdx ordering when available.
  const na = typeof a === "number" ? a : Number.NaN;
  const nb = typeof b === "number" ? b : Number.NaN;
  if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
  return String(a).localeCompare(String(b));
});

let md = "";
md += `## Polish Bakeoff Review\n\n`;
md += `<sub>Eval ID: ${resultsRoot.id || data.evalId || "—"} · Generated by promptfoo</sub>\n\n`;

for (const testKey of testOrder) {
  const list = groupedByTest.get(testKey) || [];
  if (list.length === 0) continue;

  const first = list[0];
  const desc = first.testCase?.description || first.description || "Unnamed test";
  const transcript = first.vars?.transcript || "—";

  md += `### ${escapeMd(desc)}\n\n`;
  md += `**Input**\n\n`;
  md += "```text\n" + transcript + "\n```\n\n";

  const byProvider = new Map();
  for (const r of list) {
    const pid = r.provider?.id || "—";
    byProvider.set(pid, r);
  }

  const providerOrder = providersInOrder.length > 0 ? providersInOrder : Array.from(byProvider.keys()).sort();

  md += `**Outputs**\n\n`;
  for (const pid of providerOrder) {
    const r = byProvider.get(pid);
    if (!r) continue;

    const ok = r.success ? "✅" : "❌";
    const score = typeof r.score === "number" ? r.score.toFixed(3) : "—";
    const latency = typeof r.latencyMs === "number" ? `${r.latencyMs}ms` : "—";
    const cost = typeof r.cost === "number" ? `$${r.cost.toFixed(6)}` : "n/a";

    const output = (r.response && r.response.output) || "";
    const error = r.error ? (typeof r.error === "string" ? r.error : r.error.message || JSON.stringify(r.error)) : "";

    md += `<details>\n`;
    md += `<summary>${ok} <code>${escapeHtml(providerLabel(pid))}</code> · score=${score} · latency=${latency} · cost=${cost}</summary>\n\n`;
    if (error) {
      md += `**Error**\n\n`;
      md += "```text\n" + error + "\n```\n\n";
    }
    md += `**Output**\n\n`;
    md += "```text\n" + output + "\n```\n\n";
    md += `</details>\n\n`;
  }
}

process.stdout.write(md);

function escapeMd(str) {
  return String(str).replace(/\|/g, "\\|");
}

function escapeHtml(str) {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

