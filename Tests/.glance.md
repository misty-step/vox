## Purpose
The Tests directory contains the comprehensive unit, integration, and performance test suites for the Vox application and its supporting frameworks. It validates core audio processing, provider orchestration, diagnostic logging, and user interface state transitions. The suite ensures functional correctness across the entire pipeline, from initial audio capture and encryption to final text rewriting and UI feedback. Additionally, it includes benchmarks for latency monitoring and specialized tests for accessibility compliance.

## Key Roles
- **Audio and Encryption Tests**: Validate device observation, CAF-to-Opus encoding, and 256-bit audio file encryption/decryption.
- **Provider Orchestration Tests**: Verify fallback, retry, and hedging logic for STT and Rewrite providers within `VoxCore` and `VoxProviders`.
- **Pipeline and Session Tests**: Coordinate the full dictation lifecycle, including concurrency safety, state transitions, and recovery storage.
- **Diagnostics and Performance Tests**: Ensure accurate error mapping, log rotation, and statistical analysis of performance metrics like P50 and P95 percentiles.
- **UI and Accessibility Tests**: Validate HUD state transitions, VoiceOver announcements, status bar rendering, and preference persistence.
- **Infrastructure and Mocking**: Provide shared utilities for network stubbing, file system cleanup, and hardware simulation.

## Dependencies and Caveats
- Relies on **AVFoundation** for audio buffer management, conversion, and format validation.
- Utilizes both **XCTest** and the Swift **Testing** framework for suite execution.
- Depends on external system utilities including `/usr/bin/afconvert`, `/opt/homebrew/bin/ffmpeg`, and `/usr/bin/ditto`.
- Requires specific environment variables, such as `DEEPGRAM_API_KEY` or `VOX_RUN_BENCHMARK_TESTS`, for integration and benchmark suites.
- Audio device tests include logic to skip execution in environments lacking required audio input hardware.
- `AudioRecorder` tests enforce specific macOS-compatible settings to prevent crashes during buffer processing.
- UI and session tests utilize `@MainActor` isolation to manage synchronization for state changes and interface updates.
- Diagnostic exports and log management are constrained by size and file count limits to ensure system stability.